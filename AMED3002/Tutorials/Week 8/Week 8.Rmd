---
title: "Week 8"
author: "Shivin Chander"
date: "4/28/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 2.1 B cells and EBV infected B cells (LCLs)

The following data comes from a manuscript “Evidence from genome wide association studies implicates reduced control of Epstein-Barr virus infection in multiple sclerosis susceptibility” (https://www.ncbi.nlm.nih.gov/pubmed/31039804). There were multiple goals for the RNAseq component of project:

* Identify the gene expression changes that occur when B cells are infected with EBV and transformed into LCLs.

* Determine which pathways are over-represented in the differentially expressed genes.

* Assess if there are more MS risk genes then expected by chance in the differentially expressed genes.

Use this dataset as an opportunity to explore the behaviour of a small RNA-Seq experiment. In this lab we will start by just processing and exploring the data.

IMPORTANT: The code from week 8 continues on from the code generated in week 7. The new steps introduced this week start from step 5.


```{r}
# if (!requireNamespace('BiocManager', quietly = TRUE)) 
#     install.packages('BiocManager')
```


```{r, message = FALSE, warning = FALSE}
library(tidyverse)
library(ggfortify)
library(RColorBrewer)


# If any packages of these required are not installed, they can be installed by
# first installing bioconductor: if (!requireNamespace('BiocManager', quietly =
# TRUE)) install.packages('BiocManager') then using
# BiocManager::install('PACKAGENAME')

# load packages to be used in the analysis
library(GEOquery)
library(org.Hs.eg.db)
library(limma)
library(edgeR)
library(Glimma)
library(Homo.sapiens)
library(gplots)
library(dplyr)
```


```{r}
# The count data for this GEO submission is available as a supplementary file on
# GEO. You only want to run this once...

sfiles <- getGEOSuppFiles("GSE126379")
fnames <- rownames(sfiles)

# There is only one supplemental file
Data = read.delim(fnames[1], header = TRUE)
head(Data)
```

```{r}
# Next time you can just run... fnames <-
# 'GSE126379/GSE126379_BLCL_processed.txt.gz' Data =
# read.delim(fnames[1],header=TRUE) head(Data)
```



## Q2: Tidy up the dataset and set it up for downstream analysis


```{r}
# MANIPULATE GENE ANNOTATIONS

# Genes have multiple 'identifiers' in different databases. Later on we will need
# identifiers from the ENTREZ database. To save us some pain later, lets extract
# these now using the select() function from the AnnotationDbi package. The
# ENTREZ identifiers can be found in the Homo.sapiens package.

ENTREZID <- mapIds(Homo.sapiens, keys = as.character(Data$Gene.Name), column = c("ENTREZID"), 
    keytype = "SYMBOL", multiVals = "first")
```


```{r}
genes <- data.frame(ENTREZID, SYMBOL = Data$Gene.Name)

# In this file of counts, there are multiple instances where the same gene symbol
# or entrez id appears in multiple rows. This may be due to how it was initially
# generated but as we are not able to distinguish between them (and in most cases
# the count information is very similar for the duplicate rows, we will just ask
# for just one row to be kept for any given gene name)

chooseGenes <- which(!duplicated(genes$SYMBOL) & !duplicated(genes$ENTREZID))

genes <- genes[chooseGenes, ]
Data <- Data[chooseGenes, ]


# MANIPULATE GENE COUNTS

# We do not need the RPKMs just the read counts, so just pull out these
# columns
colnames(Data)
```

```{r}
counts <- Data[, grep("Counts", colnames(Data))]

# LCL are labelled 1, B cell labelled 2. rename the columns to reflect this
colnames(counts) <- sub("Reads.Counts..BLCL_", "", colnames(counts))
colnames(counts) <- sub("1", "LCL", colnames(counts))
colnames(counts) <- sub("2", "CD19B", colnames(counts))
colnames(counts) <- sub("CD19B.", "_CD19B", colnames(counts))
colnames(counts) <- sub("LCL.", "_LCL", colnames(counts))
colnames(counts)
```

```{r}
# MAKE DGEList

# make DGEList object to connect gene counts with sample information
# BLCL <- DGEList(counts = counts, samples = samples, genes = genes)
# BLCL
```


## Q3: Further processing and normalisation of the data

```{r}
# # COUNTS NORMALIZATION
# 
# # First calculate normalization factors
# BLCL <- calcNormFactors(BLCL, method = "TMM")
# 
# # make a copy of BLCLDGEList to use in extension tab.
# BLCL2 <- BLCL
# 
# # show the nomalisation factors. For this dataset the effect of TMM-normalisation
# # is mild, as evident in the magnitude of the scaling factors, which are all
# # relatively close to 1.
# 
# BLCL$samples$norm.factors
```


## Q4: Explore data with PCA. Can you see any structure?
```{r}
# # Perform PCA
# pca <- prcomp(t(lcpm), scale = TRUE)
# # Plot results
# autoplot(pca, data = samples, colour = "group", shape = "individual")

```


```{r}
# # Use another method for dimension reduction called MDS.
# plotMDS(lcpm, labels = group)
```

```{r}
# plotMDS(lcpm, labels = individual)
```

```{r}
#interactive plot of MDS using Glimma

# glMDSPlot(lcpm, labels = paste(group, individual, sep = "_"), groups = BLCL$samples[, 
#     c("group", "individual")], launch = TRUE)

```


## Q5: Construct a design matrix and perform variance stabilisation.

limma is a versatile package for DE analysis of microarray data. However, the count based data from RNAseq has certain stastical properties that are different to microarray based data, namely that in RNAseq count data, the variance is not independent of the mean. The authors of limma delevoped the voom function which accounts for this and modifies the RNAseq count data for use with the limma package.


```{r}
# We first need to set up our design matrix, where we tell limma that we are
# interested in fitting the gene expression data against group, but also to
# include the 'individual' term, as this will account for the samples being
# paired.

# design <- model.matrix(~individual + group)
# design
```

```{r}
# v <- voom(BLCL, design, plot = TRUE)
# v
```

## Q6: Fit linear model

```{r}
# Linear modelling in limma is carried out using the 'lmFit' and 'contrasts.fit'
# functions.  These functions fit a separate model to the expression values for
# each gene. We now tell limma to fit the model specified in our design matrix
# for the voom transformed data


# fit <- lmFit(v, design)
```

## Q7: Generate moderated test statistics

```{r}
# efit <- eBayes(fit)
```

## Q8: Explore the results
```{r}
# dt_fdr <- decideTests(efit, adjust.method = "fdr", p.value = 0.05)
# summary(dt_fdr)
```

```{r}
# dt_bonf <- decideTests(efit, adjust.method = "bonferroni", p.value = 0.05)
# summary(dt_bonf)
```

```{r}
# hist(efit$p.value[, "groupLCL"])
```

```{r}
# volcanoplot(efit, coef = "groupLCL", highlight = 10, names = efit$genes$SYMBOL)
```

```{r}
# DELCLvB <- topTable(efit, coef = "groupLCL", adjust.method = "fdr", p.value = 0.05, 
#     number = Inf)
```

```{r}
# write.csv(DELCLvB, file = "DELCLvB.csv")
```

```{r}
# useCoef <- which(colnames(efit) == "groupLCL")
# plotMD(efit, column = useCoef, status = dt_fdr[, useCoef], main = colnames(efit)[useCoef], 
#     )
```

```{r}
# glMDPlot(efit, coef = useCoef, status = dt_fdr[, useCoef], main = colnames(efit)[useCoef], 
#     side.main = "ENTREZID", counts = lcpm, groups = group, launch = TRUE)
```


## Q9: Create a gene expression heatmap

```{r}
# LCLvB.topgenes <- DELCLvB$SYMBOL[1:40]
# i <- which(v$genes$SYMBOL %in% LCLvB.topgenes)
# coolmap(lcpm[i, ], margin = c(8, 6), cexRow = 0.7, cexCol = 0.7)
# 
# 
# pdf("heatmap.pdf", width = 12, height = 16)
# coolmap(lcpm[i, ], margin = c(8, 6))
# dev.off()
```

## Q10: Draw a plot of a gene of interest from the data

```{r}
# CD40 <- lcpm["CD40", ]
# df <- data.frame(CD40, group, individual)
# ggplot(df, aes(x = group, y = CD40, colour = individual)) + geom_point() + geom_line(aes(group = individual)) + 
#     theme_classic()
```





